name: Deploy Rules

on: # yamllint disable-line rule:truthy
  workflow_dispatch:

env:
  CONFIG_FILE: deployment-config.yaml
  SENTINEL_MDR_READ_APP_ID: ${{ vars.SENTINEL_MDR_READ_APP_ID }}
  SENTINEL_MDR_READ_PRIVATE_KEY: ${{ secrets.SENTINEL_MDR_READ_PRIVATE_KEY }}

permissions:
  id-token: write # for Azure login with open id

jobs:
  initialize:
    name: Deployment
    environment: production-unlocked
    runs-on: ubuntu-latest
    env:
      CUSTOMER_SUBSCRIPTION_ID: ${{ secrets.CUSTOMER_SUBSCRIPTION_ID }}
      MDR_AZURE_CREDENTIALS: ${{ secrets.MDR_AZURE_CREDENTIALS }}
    steps:
      # Obtains a short-lived token for reading from the central mdr_root repository
      # using the configured GitHub App. Required to checkout mdr_root below.
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.SENTINEL_MDR_READ_APP_ID }}
          private-key: ${{ secrets.SENTINEL_MDR_READ_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: |
            mdr_root
            mdr_ruleconverter

      # Installs required PowerShell modules for this job. We keep this here for steps
      # that are not yet migrated to the composite actions, and to ensure modules are
      # available globally in the job environment. The prepare_rulepaths action also
      # performs its own check for powershell-yaml to be self-contained.
      - name: Install PowerShell Modules
        id: install-modules
        shell: pwsh
        run: |
          $InformationPreference = 'Continue'
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          try {
            $modulesToInstall = @(
              'powershell-yaml',
              'Az.Resources',
              'SentinelARConverter'
            )
            $modulesToInstall | ForEach-Object {
              if (-not (Get-Module -Name $_ -ListAvailable)) {
                Write-Information -MessageData "Module [$_] not found, installing it..."
                Install-Module -Name $_ -ErrorAction Stop
              }
            }
          } catch {
            Write-Error -Message "Failed to install module [$_]."
            exit 1
          }
    

      # Minimal Azure CLI presence for later deployments
      - name: Set up Azure CLI
        uses: azure/cli@v2
        with:
          inlineScript: |
            echo "Azure CLI setup complete." 

      # Checkout the central rules library (mdr_root) into a folder named 'mdr_root'.
      - name: Checkout mdr_root repository
        uses: actions/checkout@v5  
        with:
          repository: ${{ github.repository_owner }}/mdr_root
          path: mdr_root
          token: ${{ steps.app-token.outputs.token }}


      # Checkout the current customer repository into 'mdr_cust'.
      - name: Checkout repository
        uses: actions/checkout@v5
        with: 
          path: mdr_cust

      # Authenticate to Azure using OpenID Connect configured for this repository/environment.
      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      # Use the centralized composite action to prepare the rule paths CSV
      - name: Prepare Rule Paths
        uses: testlab-adrian/mdr_root/.github/actions/prepare_rulepaths@v2
        with:
          # Folder names under $GITHUB_WORKSPACE where the repos are checked out
          ROOT_DIR: mdr_root
          CUST_DIR: mdr_cust
          # The customer deployment config path relative to CUST_DIR
          CONFIG_FILE: ${{ env.CONFIG_FILE }}
          # Destination CSV name under $GITHUB_WORKSPACE
          OUTPUT_CSV: content.csv

      # The remaining deployment logic still relies on content.csv and proceeds to convert
      # and deploy the rules. Once more logic is migrated to actions, these steps can be
      # simplified further.
      - name: Deploy Rules
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $InformationPreference = 'Continue'

          # Import modules required for conversion and YAML handling
          Import-Module powershell-yaml -ErrorAction Stop
          Import-Module SentinelARConverter -ErrorAction Stop

          Write-Information "Azure CLI ready"

          # Read required deployment settings from customer config
          $configPath = "${{ github.workspace }}/mdr_cust/${{ env.CONFIG_FILE }}"
          if (-not (Test-Path $configPath)) { throw "Missing deployment config at $configPath" }
          $config = (Get-Content -Raw -Path $configPath) | ConvertFrom-Yaml
          $resourceGroup = $config.Settings.'WorkSpace-Resource-Group'
          $workspaceName = $config.Settings.'Workspace-Name'

          if (-not $resourceGroup -or -not $workspaceName) {
            throw "deployment-config.yaml must include Settings -> WorkSpace-Resource-Group and Workspace-Name"
          }

          # Use the CSV produced by the Prepare Rule Paths action
          $csvPath = "${{ github.workspace }}/content.csv"
          if (-not (Test-Path $csvPath)) { throw "content.csv not found. Ensure previous steps generated it." }

          # Helper: resolve a relative rule path to the concrete file in either mdr_cust or mdr_root
          function Resolve-RulePath {
            param([string]$relativePath)
            $custPath = Join-Path "${{ github.workspace }}/mdr_cust" $relativePath
            $rootPath = Join-Path "${{ github.workspace }}/mdr_root" $relativePath
            if (Test-Path $custPath) { return $custPath }
            if (Test-Path $rootPath) { return $rootPath }
            return $null
          }

          # Helper: decide if a YAML file represents a deployable alert rule
          function Is-DeployableAlertRule {
            param([hashtable]$yaml, [string]$filePath)
            $kind = $yaml.kind
            if (-not $kind) {
              if ($yaml.query -and ($yaml.severity -or $yaml.queryFrequency -or $yaml.triggerOperator -or $yaml.suppressionDuration)) {
                return $true
              }
              if ($filePath -match '/rules/hunting/' -or ($yaml.query -and -not $yaml.severity)) { return $false }
              return $true
            }
            return ($kind -in @('Scheduled','NRT','Fusion','MicrosoftSecurityIncidentCreation','ThreatIntelligence','MLBehaviorAnalytics'))
          }

          # Iterate the produced CSV and deploy eligible rules
          $lines = Get-Content -Path $csvPath | Select-Object -Skip 1
          foreach ($line in $lines) {
            if (-not ($line -match '^(.*?),(.*)$')) { continue }
            $relativePath = $matches[1]
            $ruleId = $matches[2]

            $fullPath = Resolve-RulePath -relativePath $relativePath
            if (-not $fullPath) { Write-Warning "File not found for relative path: $relativePath. Skipping."; continue }

            try {
              $yaml = Get-Content -Raw -Path $fullPath | ConvertFrom-Yaml
            } catch { Write-Warning "Failed to parse YAML for $fullPath. Skipping."; continue }

            if (-not (Is-DeployableAlertRule -yaml $yaml -filePath $fullPath)) {
              Write-Host "Skipping non-alert rule (likely hunting query): $relativePath"; continue
            }

            if (-not $ruleId -and $yaml.id) { $ruleId = $yaml.id }
            if (-not $ruleId) { Write-Warning "No rule id found for $relativePath. Skipping."; continue }

            # Convert YAML -> ARM template to deploy
            $tmpJson = Join-Path $env:RUNNER_TEMP ("$ruleId.json")
            try {
              Convert-SentinelARYamlToArm -Filename $fullPath -OutFile $tmpJson | Out-Null
            } catch {
              Write-Warning "Failed to convert YAML to ARM for $relativePath. Error: $($_.Exception.Message)"; continue
            }

            # Deploy ARM template into the resource group with workspace as parameter
            try {
              Write-Host "Deploying rule $ruleId from $relativePath via ARM template"
              az deployment group create --resource-group $resourceGroup --mode Incremental --name "deploy-${ruleId}" --template-file "$tmpJson" --parameters workspace="$workspaceName" --only-show-errors 1>$null
            } catch {
              Write-Warning "Failed to deploy ARM for $ruleId ($relativePath). Error: $($_.Exception.Message)"
            }
          }

      - name: Deploy Rules with mdr_ruleconverter
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $InformationPreference = 'Continue'

          # Ensure YAML parsing available
          Import-Module powershell-yaml -ErrorAction Stop

          # Paths
          $workspaceRoot = "${{ github.workspace }}"
          $csvPath = Join-Path $workspaceRoot 'content.csv'
          if (-not (Test-Path $csvPath)) { throw "content.csv not found. Ensure 'Prepare Rule Paths' step ran." }

          # Read config for RG and Workspace
          $configPath = Join-Path $workspaceRoot "mdr_cust/${{ env.CONFIG_FILE }}"
          if (-not (Test-Path $configPath)) { throw "Missing deployment config at $configPath" }
          $config = (Get-Content -Raw -Path $configPath) | ConvertFrom-Yaml
          $resourceGroup = $config.Settings.'WorkSpace-Resource-Group'
          $workspaceName = $config.Settings.'Workspace-Name'
          if (-not $resourceGroup -or -not $workspaceName) {
            throw "deployment-config.yaml must include Settings -> WorkSpace-Resource-Group and Workspace-Name"
          }

          # Locate and import the YamlToArm module from mdr_ruleconverter
          $modulePath = Join-Path $workspaceRoot 'mdr_ruleconverter/Modules/YamlToArm.psm1'
          if (-not (Test-Path $modulePath)) { throw "YamlToArm module not found at $modulePath" }
          Import-Module -Name $modulePath -Force -ErrorAction Stop

          # Resolve paths helper
          function Resolve-RulePath {
            param([string]$relativePath)
            $custPath = Join-Path "$workspaceRoot/mdr_cust" $relativePath
            $rootPath = Join-Path "$workspaceRoot/mdr_root" $relativePath
            if (Test-Path $custPath) { return $custPath }
            if (Test-Path $rootPath) { return $rootPath }
            return $null
          }

          # Prepare output location for the combined ARM template
          $outDir = Join-Path $env:RUNNER_TEMP 'mdr_ruleconverter_output'
          $null = New-Item -ItemType Directory -Path $outDir -Force
          $outFile = Join-Path $outDir 'armTemplate.json'
          if (Test-Path $outFile) { Remove-Item -LiteralPath $outFile -Force }

          # Determine workspace location (fallback to westeurope)
          $workspaceLocation = ''
          try { $workspaceLocation = (az monitor log-analytics workspace show --resource-group $resourceGroup --workspace-name $workspaceName --query location -o tsv 2>$null).Trim() } catch {}
          if (-not $workspaceLocation) { $workspaceLocation = 'westeurope' }

          Write-Host "Building ARM template with mdr_ruleconverter from filtered CSV"

          # Iterate CSV and merge each file into a single template
          $lines = Get-Content -Path $csvPath | Select-Object -Skip 1
          $processed = 0
          foreach ($line in $lines) {
            if (-not ($line -match '^(.*?),(.*)$')) { continue }
            $relativePath = $matches[1]

            $fullPath = Resolve-RulePath -relativePath $relativePath
            if (-not $fullPath) { Write-Warning "File not found for relative path: $relativePath. Skipping."; continue }

            try {
              Merge-ContentTemplate -InputFile $fullPath -OutputFile $outFile -Workspace $workspaceName -Location $workspaceLocation
              $processed++
            } catch {
              Write-Warning ("Failed to merge file: " + $relativePath + ". Error: " + $_.Exception.Message)
            }
          }

          if ($processed -eq 0) { Write-Host 'No files to convert. Skipping.'; exit 0 }
          if (-not (Test-Path $outFile)) { throw "ARM template was not created at $outFile" }

          # Deploy the generated ARM template
          Write-Host ("Deploying combined ARM template: {0}" -f $outFile)
          az deployment group create `
            --resource-group $resourceGroup `
            --mode Incremental `
            --name ("deploy-mdrrc-{0}" -f (Get-Date -Format 'yyyyMMddHHmmss')) `
            --template-file "$outFile" `
            --parameters workspace="$workspaceName" workspace-location="$workspaceLocation" `
            --only-show-errors 1>$null