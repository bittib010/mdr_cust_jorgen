name: Deploy Rules

on: # yamllint disable-line rule:truthy
  workflow_dispatch:
  push: # remove when not testing
    branches:
      - master


env:
  CONFIG_FILE: deployment-config.yaml
  SENTINEL_MDR_READ_APP_ID: ${{ vars.SENTINEL_MDR_READ_APP_ID }}
  SENTINEL_MDR_READ_PRIVATE_KEY: ${{ secrets.SENTINEL_MDR_READ_PRIVATE_KEY }}

permissions:
  id-token: write # for Azure login with open id
 

jobs:
  initialize:
    runs-on: ubuntu-latest
    env:
      CUSTOMER_SUBSCRIPTION_ID: ${{ secrets.CUSTOMER_SUBSCRIPTION_ID }}
      MDR_AZURE_CREDENTIALS: ${{ secrets.MDR_AZURE_CREDENTIALS }}
    steps:

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.SENTINEL_MDR_READ_APP_ID }}
          private-key: ${{ secrets.SENTINEL_MDR_READ_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: |
            testlab-adrian/mdr_root

      - name: Set up Azure CLI
        uses: azure/cli@v2
        with:
          inlineScript: |
            echo "Azure CLI setup complete." 

      - name: Checkout mdr_root repository
        uses: actions/checkout@v5  
        with:
          repository: testlab-adrian/mdr_root
          path: mdr_root
          token: ${{ steps.app-token.outputs.token }}


      # Checkout current repository
      - name: Checkout repository
        uses: actions/checkout@v5
        with: 
          path: mdr_cust

      # New: Authenticate with MDR tenant SP (will use Azure Lighthouse delegated access to target the customer subscription)
      - name: Azure login (MDR tenant via Lighthouse delegation)
        uses: azure/login@v2
        with:
          creds: ${{ env.MDR_AZURE_CREDENTIALS }}

      - name: Set target subscription (customer via Lighthouse)
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${CUSTOMER_SUBSCRIPTION_ID:-}" ]; then
            echo "CUSTOMER_SUBSCRIPTION_ID secret is missing." >&2
            exit 1
          fi
          az account set --subscription "$CUSTOMER_SUBSCRIPTION_ID"
          echo "Using subscription: $(az account show --query id -o tsv)"

      - name: Verify delegated access
        shell: bash
        run: |
          set -e
          echo "Active tenant: $(az account show --query tenantId -o tsv)"
          echo "Available workspaces in subscription (first 5):"
          az monitor.log-analytics.workspace list --query "[].{name:name, rg:resourceGroup}" -o table | head -n 6 || true

      - name: Install PowerShell Modules
        id: install-modules
        shell: pwsh
        run: |
          $InformationPreference = 'Continue'
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          try {
            $modulesToInstall = @(
              'Az.Resources',
              'powershell-yaml'
            )
            $modulesToInstall | ForEach-Object {
              if (-not (Get-Module -Name $_ -ListAvailable)) {
                Write-Information -MessageData "Module [$_] not found, installing it..."
                Install-Module -Name $_ -ErrorAction Stop
              }
            }
          } catch {
            Write-Error -Message "Failed to install module [$_]."
            exit 1
          }

      - name: Load customer settings and Lighthouse parameters
        shell: pwsh
        run: |
          Import-Module powershell-yaml -ErrorAction Stop
          $ErrorActionPreference = 'Stop'
          $cfgPath = Join-Path "${{ github.workspace }}/mdr_cust" 'deployment-config.yaml'
          $lhParamPath = Join-Path "${{ github.workspace }}/mdr_cust" 'lighthouse/lighthouse-template.parameters.json'

          $rg = $env:AZURE_RG
          $workspace = $env:AZURE_WORKSPACE
          $autoRg = $null

          if (Test-Path $cfgPath) {
            try {
              $cfg = Get-Content -Raw -Path $cfgPath | ConvertFrom-Yaml
              if (-not $rg -and $cfg -and $cfg.Settings) { $rg = $cfg.Settings.'WorkSpace-Resource-Group' }
              if (-not $workspace -and $cfg -and $cfg.Settings) { $workspace = $cfg.Settings.'Workspace-Name' }
              if ($cfg -and $cfg.Settings) { $autoRg = $cfg.Settings.'Automation-Resource-Group' }
            } catch { Write-Host "Failed to parse deployment-config.yaml" }
          }

          if (Test-Path $lhParamPath) {
            try {
              $lh = Get-Content -Raw -Path $lhParamPath | ConvertFrom-Json
              $lhRg = $lh.parameters.SentinelResourceGroup.value
              $lhAutoRg = $lh.parameters.SecurityAutomationResourceGroup.value
              if (-not $rg -and $lhRg) { $rg = $lhRg }
              if (-not $autoRg -and $lhAutoRg) { $autoRg = $lhAutoRg }
            } catch { Write-Host "Failed to parse lighthouse-template.parameters.json" }
          }

          # Fallback: attempt to discover workspace in RG if not provided
          if (-not $workspace -and $rg) {
            try {
              $ws = az monitor log-analytics workspace list -g $rg --query "[0].name" -o tsv 2>$null
              if ($LASTEXITCODE -eq 0 -and $ws) { $workspace = $ws }
            } catch {}
          }

          if (-not $rg -or -not $workspace) {
            Write-Error "Could not determine AZURE_RG or AZURE_WORKSPACE from config or parameters. Set repo variables AZURE_RG/AZURE_WORKSPACE or fill deployment-config.yaml and lighthouse parameters."
            exit 1
          }

          "AZURE_RG=$rg" | Out-File -FilePath $env:GITHUB_ENV -Append
          "AZURE_WORKSPACE=$workspace" | Out-File -FilePath $env:GITHUB_ENV -Append
          if ($autoRg) { "AZURE_AUTOMATION_RG=$autoRg" | Out-File -FilePath $env:GITHUB_ENV -Append }

      # Loop the /mdr_root folders subfolder: artefacts recursively
      - name: Add base content to artefacts
        shell: pwsh
        run: |
          $csvPath = "${{ github.workspace }}/content.csv"
          # Write CSV header if the file doesn't exist
          if (-not (Test-Path $csvPath)) {
          "Path,ID" | Out-File -FilePath $csvPath
            }
            
            Get-ChildItem "${{ github.workspace }}/mdr_root" -Recurse -Filter *.yaml | ForEach-Object {
          Write-Host "Found artefacts file: $($_.FullName)"
          $path = $_.FullName
          $path = $path -replace [regex]::Escape("${{ github.workspace }}/mdr_root/"), ""
          $path = $path -replace '\\', '/'

          # Read YAML file and extract the "id" field
          try {
            $yamlContent = Get-Content -Raw -Path $_.FullName
            $yamlObject = ConvertFrom-Yaml $yamlContent
            $id = $yamlObject.id
          }
          catch {
            Write-Host "Failed to parse YAML from $($_.FullName)"
            $id = ""
          }

          Write-Host "Saving path: $path with ID: $id"
          "$path,$id" | Out-File -Append -FilePath $csvPath
            }

      - name: Add, exclude and override content
        shell: pwsh
        run: |
          $csvPath = "${{ github.workspace }}/content.csv"
          
          # Ensure CSV file exists with header
          if (-not (Test-Path $csvPath)) {
              "Path,ID" | Out-File -FilePath $csvPath
          }
          
          # Import existing CSV content (ignoring header issues)
          $csvContent = @{
          }
          if (Test-Path $csvPath) {
              $lines = Get-Content -Path $csvPath | Select-Object -Skip 1
              foreach ($line in $lines) {
                  if ($line -match "^(.*?),(.*)$") {
                      $csvContent[$matches[2]] = $matches[1]
                  }
              }
          }
          
          # Process every YAML file in mdr_cust folder
          $files = Get-ChildItem "${{ github.workspace }}/mdr_cust/artifacts" -Recurse -Include *.yaml,*.yml

          foreach ($file in $files) {
              $relativePath = $file.FullName -replace [regex]::Escape("${{ github.workspace }}/mdr_cust/"), ""
              $relativePath = $relativePath -replace '\\', '/'
              Write-Host "Processing file: $($file.FullName) with relative path: $relativePath"
              
              try {
                  $yamlContent = Get-Content -Raw -Path $file.FullName
                  $yamlObj = $yamlContent | ConvertFrom-Yaml
                  $id = $yamlObj.id
              }
              catch {
                  Write-Host "Failed to parse YAML from $($file.FullName)"
                  $id = ""
              }
              
              if ($id -and $id.Trim() -ne "") {
                  # If file id already exists, update its path; otherwise, add new entry
                  $csvContent[$id] = $relativePath
              }
              else {
                  Write-Host "Skipping file $($file.FullName) due to invalid or empty id"
              }
          }
          
          # Update CSV content file by rewriting it with header and new content
          $csvLines = @("Path,ID")
          foreach ($key in $csvContent.Keys) {
              $csvLines += "$(
                $csvContent[$key]
              ),$key"
          }
          
          # Process ExcludeRules from deployment-config.yaml
          $configPath = "${{ github.workspace }}/mdr_cust/deployment-config.yaml"
          if (Test-Path $configPath) {
              try {
                  $configContent = Get-Content -Raw -Path $configPath
                  $config = $configContent | ConvertFrom-Yaml
                  if ($config.ExcludeRules) {
                      foreach ($rule in $config.ExcludeRules) {
                          if ($rule.id -and $csvContent.ContainsKey($rule.id)) {
                              $csvContent.Remove($rule.id)
                          }
                      }
                      # Rebuild CSV content after exclusion
                      $csvLines = @("Path,ID")
                      foreach ($key in $csvContent.Keys) {
                          $csvLines += "$(
                            $csvContent[$key]
                          ),$key"
                      }
                  }
              }
              catch {
                  Write-Host "Failed to parse deployment-config.yaml"
              }
          }
          
          $csvLines | Out-File -FilePath $csvPath -Encoding utf8

      # OLD: Deploy selected rules to the customer's Sentinel workspace (direct customer SP login)
      # - name: Deploy Sentinel rules
      #   shell: pwsh
      #   run: |
      #     Import-Module powershell-yaml -ErrorAction Stop
      #     # ...existing code...
      #     # Old direct deployment via az rest using customer-tenant service principal
      #     # ...existing code...

      # New: Deploy selected rules via Azure Lighthouse delegated access using Innofactor-MDR module
      - name: Deploy content (Innofactor-MDR via Lighthouse)
        shell: pwsh
        run: |
          Import-Module powershell-yaml -ErrorAction Stop
          Import-Module Az.Resources -ErrorAction Stop

          $ErrorActionPreference = 'Stop'

          # Authenticate Az PowerShell with the same MDR credentials (for template deployments)
          if (-not $env:MDR_AZURE_CREDENTIALS) { throw 'MDR_AZURE_CREDENTIALS not set' }
          $creds = $env:MDR_AZURE_CREDENTIALS | ConvertFrom-Json
          $tenantId = $creds.tenantId
          $appId = $creds.clientId
          $secret = $creds.clientSecret
          $subId = if ($env:CUSTOMER_SUBSCRIPTION_ID) { $env:CUSTOMER_SUBSCRIPTION_ID } else { $creds.subscriptionId }

          $sec = ConvertTo-SecureString -String $secret -AsPlainText -Force
          $spCred = New-Object System.Management.Automation.PSCredential($appId, $sec)
          Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Subscription $subId -Credential $spCred | Out-Null
          Set-AzContext -Subscription $subId | Out-Null

          # Locate and import Innofactor-MDR module from mdr_root checkout; fallback to dot-sourcing Public/Private
          $rootPath = "${{ github.workspace }}"
          $modulesPath = Join-Path $rootPath 'mdr_root/Modules'
          $moduleFolder = Join-Path $modulesPath 'Innofactor-MDR'
          if (Test-Path -LiteralPath $moduleFolder -PathType Container) {
            try { Import-Module -Name $moduleFolder -Force -ErrorAction Stop } catch {}
          }
          if (-not (Get-Module -Name Innofactor-MDR)) {
            Write-Host 'Module folder not found or import failed. Falling back to dot-sourcing Public/Private functions.'
            Get-ChildItem -Path (Join-Path $modulesPath 'Private') -Filter *.ps1 -File -Recurse -ErrorAction SilentlyContinue | ForEach-Object { . $_.FullName }
            Get-ChildItem -Path (Join-Path $modulesPath 'Public') -Filter *.ps1 -File -Recurse -ErrorAction SilentlyContinue | ForEach-Object { . $_.FullName }
          }

          # Prepare paths
          $customerRoot = Join-Path $rootPath 'mdr_cust'
          $templatePath = Join-Path $customerRoot 'artifacts'
          $outputPath = Join-Path $rootPath 'output'
          if (-not (Test-Path $outputPath)) { New-Item -ItemType Directory -Path $outputPath | Out-Null }

          # If no ARM templates are present, try to merge/generate them first
          $hasJson = @(Get-ChildItem -Path $templatePath -Recurse -Filter *.json -ErrorAction SilentlyContinue).Count -gt 0
          if (-not $hasJson) {
            Write-Host 'No ARM .json templates found under artifacts. Attempting to generate via Merge-ContentTemplate...'
            if (Get-Command -Name Merge-ContentTemplate -ErrorAction SilentlyContinue) {
              try {
                Merge-ContentTemplate -ConfigFile "${{ env.CONFIG_FILE }}" -OutputPath $outputPath -CurrentCustomerRootPath $customerRoot
                # After merge, switch templatePath to output directory
                $templatePath = $outputPath
              } catch {
                throw "Failed to generate templates via Merge-ContentTemplate: $_"
              }
            } else {
              # Try to dot-source scripts/Merge-ContentTemplates.ps1 if available
              $mergeScript = Join-Path $rootPath 'mdr_root/scripts/Merge-ContentTemplates.ps1'
              if (Test-Path $mergeScript) {
                . $mergeScript
                if (Get-Command -Name Merge-ContentTemplate -ErrorAction SilentlyContinue) {
                  Merge-ContentTemplate -ConfigFile "${{ env.CONFIG_FILE }}" -OutputPath $outputPath -CurrentCustomerRootPath $customerRoot
                  $templatePath = $outputPath
                } else {
                  Write-Warning 'Merge-ContentTemplate not available after dot-sourcing. Proceeding without generation.'
                }
              } else {
                Write-Warning 'Merge-ContentTemplates.ps1 not found. Proceeding without generation.'
              }
            }
          }

          # Align with composite example: run from template path
          Set-Location -LiteralPath $templatePath

          # Test (what-if) toggle support via env WHAT_IF (optional)
          $testDeploy = $false
          if ($env:WHAT_IF -and ($env:WHAT_IF -eq 'true' -or $env:WHAT_IF -eq '1')) { $testDeploy = $true }

          # Execute deployment driven by deployment-config.yaml
          Start-ContentDeploy `
            -ConfigFile "${{ env.CONFIG_FILE }}" `
            -OutputPath $outputPath `
            -TemplatePath $templatePath `
            -Test:$testDeploy
