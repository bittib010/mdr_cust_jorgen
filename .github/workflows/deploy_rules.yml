name: Deploy Rules

on: # yamllint disable-line rule:truthy
  workflow_dispatch:

env:
  CONFIG_FILE: deployment-config.yaml
  SENTINEL_MDR_READ_APP_ID: ${{ vars.SENTINEL_MDR_READ_APP_ID }}
  SENTINEL_MDR_READ_PRIVATE_KEY: ${{ secrets.SENTINEL_MDR_READ_PRIVATE_KEY }}

permissions:
  id-token: write # for Azure login with open id

jobs:
  initialize:
    name: Deployment
    environment: production-unlocked
    runs-on: ubuntu-latest
    env:
      CUSTOMER_SUBSCRIPTION_ID: ${{ secrets.CUSTOMER_SUBSCRIPTION_ID }}
      MDR_AZURE_CREDENTIALS: ${{ secrets.MDR_AZURE_CREDENTIALS }}
    steps:
      # Obtains a short-lived token for reading from the central mdr_root repository
      # using the configured GitHub App. Required to checkout mdr_root below.
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.SENTINEL_MDR_READ_APP_ID }}
          private-key: ${{ secrets.SENTINEL_MDR_READ_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: |
            mdr_root

      # Installs required PowerShell modules for this job. We keep this here for steps
      # that are not yet migrated to the composite actions, and to ensure modules are
      # available globally in the job environment. The prepare_rulepaths action also
      # performs its own check for powershell-yaml to be self-contained.
      - name: Install PowerShell Modules
        id: install-modules
        shell: pwsh
        run: |
          $InformationPreference = 'Continue'
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          try {
            $modulesToInstall = @(
              'powershell-yaml',
              'Az.Resources',
              'SentinelARConverter'
            )
            $modulesToInstall | ForEach-Object {
              if (-not (Get-Module -Name $_ -ListAvailable)) {
                Write-Information -MessageData "Module [$_] not found, installing it..."
                Install-Module -Name $_ -ErrorAction Stop
              }
            }
          } catch {
            Write-Error -Message "Failed to install module [$_]."
            exit 1
          }
    

      # Minimal Azure CLI presence for later deployments
      - name: Set up Azure CLI
        uses: azure/cli@v2
        with:
          inlineScript: |
            echo "Azure CLI setup complete." 

      # Checkout the central rules library (mdr_root) into a folder named 'mdr_root'.
      - name: Checkout mdr_root repository
        uses: actions/checkout@v5  
        with:
          repository: ${{ github.repository_owner }}/mdr_root
          path: mdr_root
          token: ${{ steps.app-token.outputs.token }}


      # Checkout the current customer repository into 'mdr_cust'.
      - name: Checkout repository
        uses: actions/checkout@v5
        with: 
          path: mdr_cust

      # Authenticate to Azure using OpenID Connect configured for this repository/environment.
      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}



      # Loop the /mdr_root folders subfolder: artefacts recursively
      - name: Add base content to artefacts
        shell: pwsh
        run: |
          $csvPath = "${{ github.workspace }}/content.csv"
          # Write CSV header if the file doesn't exist
          if (-not (Test-Path $csvPath)) {
          "Path,ID" | Out-File -FilePath $csvPath
            }
            
            Get-ChildItem "${{ github.workspace }}/mdr_root" -Recurse -Filter *.yaml | ForEach-Object {
          Write-Host "Found artefacts file: $($_.FullName)"
          $path = $_.FullName
          $path = $path -replace [regex]::Escape("${{ github.workspace }}/mdr_root/"), ""
          $path = $path -replace '\\', '/'

          # Read YAML file and extract the "id" field
          try {
            $yamlContent = Get-Content -Raw -Path $_.FullName
            $yamlObject = ConvertFrom-Yaml $yamlContent
            $id = $yamlObject.id
          }
          catch {
            Write-Host "Failed to parse YAML from $($_.FullName)"
            $id = ""
          }

          Write-Host "Saving path: $path with ID: $id"
          "$path,$id" | Out-File -Append -FilePath $csvPath
            }

      - name: Add, exclude and override content
        shell: pwsh
        run: |
          $csvPath = "${{ github.workspace }}/content.csv"
          
          # Ensure CSV file exists with header
          if (-not (Test-Path $csvPath)) {
              "Path,ID" | Out-File -FilePath $csvPath
          }
          
          # Import existing CSV content (ignoring header issues)
          $csvContent = @{
          }
          if (Test-Path $csvPath) {
              $lines = Get-Content -Path $csvPath | Select-Object -Skip 1
              foreach ($line in $lines) {
                  if ($line -match "^(.*?),(.*)$") {
                      $csvContent[$matches[2]] = $matches[1]
                  }
              }
          }
          
          # Process every YAML file in mdr_cust folder
          $files = Get-ChildItem "${{ github.workspace }}/mdr_cust/artifacts" -Recurse -Include *.yaml,*.yml

          foreach ($file in $files) {
              $relativePath = $file.FullName -replace [regex]::Escape("${{ github.workspace }}/mdr_cust/"), ""
              $relativePath = $relativePath -replace '\\', '/'
              Write-Host "Processing file: $($file.FullName) with relative path: $relativePath"
              
              try {
                  $yamlContent = Get-Content -Raw -Path $file.FullName
                  $yamlObj = $yamlContent | ConvertFrom-Yaml
                  $id = $yamlObj.id
              }
              catch {
                  Write-Host "Failed to parse YAML from $($file.FullName)"
                  $id = ""
              }
              
              if ($id -and $id.Trim() -ne "") {
                  # If file id already exists, update its path; otherwise, add new entry
                  $csvContent[$id] = $relativePath
              }
              else {
                  Write-Host "Skipping file $($file.FullName) due to invalid or empty id"
              }
          }
          
          # Update CSV content file by rewriting it with header and new content
          $csvLines = @("Path,ID")
          foreach ($key in $csvContent.Keys) {
              $csvLines += "$(
                $csvContent[$key]
              ),$key"
          }
          
          # Process ExcludeRules from deployment-config.yaml
          $configPath = "${{ github.workspace }}/mdr_cust/deployment-config.yaml"
          if (Test-Path $configPath) {
              try {
                  $configContent = Get-Content -Raw -Path $configPath
                  $config = $configContent | ConvertFrom-Yaml
                  if ($config.ExcludeRules) {
                      foreach ($rule in $config.ExcludeRules) {
                          if ($rule.id -and $csvContent.ContainsKey($rule.id)) {
                              $csvContent.Remove($rule.id)
                          }
                      }
                      # Rebuild CSV content after exclusion
                      $csvLines = @("Path,ID")
                      foreach ($key in $csvContent.Keys) {
                          $csvLines += "$(
                            $csvContent[$key]
                          ),$key"
                      }
                  }
              }
              catch {
                  Write-Host "Failed to parse deployment-config.yaml"
              }
          }
          
          $csvLines | Out-File -FilePath $csvPath -Encoding utf8



      # Deprecated inline steps for building content.csv are being replaced by the
      # new composite action below. Keeping comments to document the transition:
      #  - Previously we seeded from mdr_root, then overlaid mdr_cust and applied exclusions
      #  - The same logic is now encapsulated in .github/actions/prepare_rulepaths in mdr_root

      # New step: call the centralized composite action that prepares the rule paths CSV.
      # It accepts inputs to locate the two checkouts and the deployment-config file,
      # and writes the resulting CSV to the workspace as content.csv by default.
      - name: Prepare Rule Paths (demo)
        uses: testlab-adrian/mdr_root/.github/actions/prepare_rulepaths@v1
        with:
          # Folder names under $GITHUB_WORKSPACE where the repos are checked out
          ROOT_DIR: mdr_root
          CUST_DIR: mdr_cust
          # The customer deployment config path relative to CUST_DIR
          CONFIG_FILE: ${{ env.CONFIG_FILE }}
          # Destination CSV name under $GITHUB_WORKSPACE
          OUTPUT_CSV: content.csv

      # The remaining deployment logic still relies on content.csv and proceeds to convert
      # and deploy the rules. Once more logic is migrated to actions, these steps can be
      # simplified further.
      - name: Deploy Rules
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $InformationPreference = 'Continue'

          # Import modules required for conversion and YAML handling
          Import-Module powershell-yaml -ErrorAction Stop
          Import-Module SentinelARConverter -ErrorAction Stop

          Write-Information "Azure CLI ready"

          # Read required deployment settings from customer config
          $configPath = "${{ github.workspace }}/mdr_cust/${{ env.CONFIG_FILE }}"
          if (-not (Test-Path $configPath)) { throw "Missing deployment config at $configPath" }
          $config = (Get-Content -Raw -Path $configPath) | ConvertFrom-Yaml
          $resourceGroup = $config.Settings.'WorkSpace-Resource-Group'
          $workspaceName = $config.Settings.'Workspace-Name'

          if (-not $resourceGroup -or -not $workspaceName) {
            throw "deployment-config.yaml must include Settings -> WorkSpace-Resource-Group and Workspace-Name"
          }

          # Use the CSV produced by the Prepare Rule Paths action
          $csvPath = "${{ github.workspace }}/content.csv"
          if (-not (Test-Path $csvPath)) { throw "content.csv not found. Ensure previous steps generated it." }

          # Helper: resolve a relative rule path to the concrete file in either mdr_cust or mdr_root
          function Resolve-RulePath {
            param([string]$relativePath)
            $custPath = Join-Path "${{ github.workspace }}/mdr_cust" $relativePath
            $rootPath = Join-Path "${{ github.workspace }}/mdr_root" $relativePath
            if (Test-Path $custPath) { return $custPath }
            if (Test-Path $rootPath) { return $rootPath }
            return $null
          }

          # Helper: decide if a YAML file represents a deployable alert rule
          function Is-DeployableAlertRule {
            param([hashtable]$yaml, [string]$filePath)
            $kind = $yaml.kind
            if (-not $kind) {
              if ($yaml.query -and ($yaml.severity -or $yaml.queryFrequency -or $yaml.triggerOperator -or $yaml.suppressionDuration)) {
                return $true
              }
              if ($filePath -match '/rules/hunting/' -or ($yaml.query -and -not $yaml.severity)) { return $false }
              return $true
            }
            return ($kind -in @('Scheduled','NRT','Fusion','MicrosoftSecurityIncidentCreation','ThreatIntelligence','MLBehaviorAnalytics'))
          }

          # Iterate the produced CSV and deploy eligible rules
          $lines = Get-Content -Path $csvPath | Select-Object -Skip 1
          foreach ($line in $lines) {
            if (-not ($line -match '^(.*?),(.*)$')) { continue }
            $relativePath = $matches[1]
            $ruleId = $matches[2]

            $fullPath = Resolve-RulePath -relativePath $relativePath
            if (-not $fullPath) { Write-Warning "File not found for relative path: $relativePath. Skipping."; continue }

            try {
              $yaml = Get-Content -Raw -Path $fullPath | ConvertFrom-Yaml
            } catch { Write-Warning "Failed to parse YAML for $fullPath. Skipping."; continue }

            if (-not (Is-DeployableAlertRule -yaml $yaml -filePath $fullPath)) {
              Write-Host "Skipping non-alert rule (likely hunting query): $relativePath"; continue
            }

            if (-not $ruleId -and $yaml.id) { $ruleId = $yaml.id }
            if (-not $ruleId) { Write-Warning "No rule id found for $relativePath. Skipping."; continue }

            # Convert YAML -> ARM template to deploy
            $tmpJson = Join-Path $env:RUNNER_TEMP ("$ruleId.json")
            try {
              Convert-SentinelARYamlToArm -Filename $fullPath -OutFile $tmpJson | Out-Null
            } catch {
              Write-Warning "Failed to convert YAML to ARM for $relativePath. Error: $($_.Exception.Message)"; continue
            }

            # Deploy ARM template into the resource group with workspace as parameter
            try {
              Write-Host "Deploying rule $ruleId from $relativePath via ARM template"
              az deployment group create --resource-group $resourceGroup --mode Incremental --name "deploy-${ruleId}" --template-file "$tmpJson" --parameters workspace="$workspaceName" --only-show-errors 1>$null
            } catch {
              Write-Warning "Failed to deploy ARM for $ruleId ($relativePath). Error: $($_.Exception.Message)"
            }
          }