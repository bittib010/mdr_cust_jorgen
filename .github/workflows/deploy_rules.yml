name: Deploy Rules

on: # yamllint disable-line rule:truthy
  workflow_dispatch:

env:
  CONFIG_FILE: deployment-config.yaml
  SENTINEL_MDR_READ_APP_ID: ${{ vars.SENTINEL_MDR_READ_APP_ID }}
  SENTINEL_MDR_READ_PRIVATE_KEY: ${{ secrets.SENTINEL_MDR_READ_PRIVATE_KEY }}

permissions:
  id-token: write # for Azure login with open id

jobs:
  initialize:
    name: Deployment
    environment: production-unlocked
    runs-on: ubuntu-latest
    env:
      CUSTOMER_SUBSCRIPTION_ID: ${{ secrets.CUSTOMER_SUBSCRIPTION_ID }}
      MDR_AZURE_CREDENTIALS: ${{ secrets.MDR_AZURE_CREDENTIALS }}
    steps:
      # Obtains a short-lived token for reading from the central mdr_root repository
      # using the configured GitHub App. Required to checkout mdr_root below.
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.SENTINEL_MDR_READ_APP_ID }}
          private-key: ${{ secrets.SENTINEL_MDR_READ_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: |
            mdr_root
            mdr_ruleconverter

      # Installs required PowerShell modules for this job. We keep this here for steps
      # that are not yet migrated to the composite actions, and to ensure modules are
      # available globally in the job environment. The prepare_rulepaths action also
      # performs its own check for powershell-yaml to be self-contained.
      - name: Install PowerShell Modules
        id: install-modules
        shell: pwsh
        run: |
          $InformationPreference = 'Continue'
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          try {
            $modulesToInstall = @(
              'powershell-yaml',
              'Az.Resources'
              )
            $modulesToInstall | ForEach-Object {
              if (-not (Get-Module -Name $_ -ListAvailable)) {
                Write-Information -MessageData "Module [$_] not found, installing it..."
                Install-Module -Name $_ -ErrorAction Stop
              }
            }
          } catch {
            Write-Error -Message "Failed to install module [$_]."
            exit 1
          }
    

      # Minimal Azure CLI presence for later deployments
      - name: Set up Azure CLI
        uses: azure/cli@v2
        with:
          inlineScript: |
            echo "Azure CLI setup complete." 

      # Checkout the central rules library (mdr_root) into a folder named 'mdr_root'.
      - name: Checkout mdr_root repository
        uses: actions/checkout@v5  
        with:
          repository: ${{ github.repository_owner }}/mdr_root
          path: mdr_root
          token: ${{ steps.app-token.outputs.token }}


      # Checkout the mdr_ruleconverter repository to access the YamlToArm module
      - name: Checkout mdr_ruleconverter repository
        uses: actions/checkout@v5
        with:
          repository: ${{ github.repository_owner }}/mdr_ruleconverter
          path: mdr_ruleconverter
          token: ${{ steps.app-token.outputs.token }}


      # Checkout the current customer repository into 'mdr_cust'.
      - name: Checkout repository
        uses: actions/checkout@v5
        with: 
          path: mdr_cust

      # Authenticate to Azure using OpenID Connect configured for this repository/environment.
      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      # Use the centralized composite action to prepare the rule paths CSV
      - name: Prepare Rule Paths
        uses: testlab-adrian/mdr_root/.github/actions/prepare_rulepaths@v2
        with:
          # Folder names under $GITHUB_WORKSPACE where the repos are checked out
          ROOT_DIR: mdr_root
          CUST_DIR: mdr_cust
          # The customer deployment config path relative to CUST_DIR
          CONFIG_FILE: ${{ env.CONFIG_FILE }}
          # Destination CSV name under $GITHUB_WORKSPACE
          OUTPUT_CSV: content.csv

      - name: Deploy Rules with mdr_ruleconverter
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $InformationPreference = 'Continue'

          # Ensure YAML parsing available
          Import-Module powershell-yaml -ErrorAction Stop

          # Paths
          $workspaceRoot = "${{ github.workspace }}"
          $csvPath = Join-Path $workspaceRoot 'content.csv'
          if (-not (Test-Path $csvPath)) { throw "content.csv not found. Ensure 'Prepare Rule Paths' step ran." }

          # Read config for RG and Workspace
          $configPath = Join-Path $workspaceRoot "mdr_cust/${{ env.CONFIG_FILE }}"
          if (-not (Test-Path $configPath)) { throw "Missing deployment config at $configPath" }
          $config = (Get-Content -Raw -Path $configPath) | ConvertFrom-Yaml
          $resourceGroup = $config.Settings.'WorkSpace-Resource-Group'
          $workspaceName = $config.Settings.'Workspace-Name'
          if (-not $resourceGroup -or -not $workspaceName) {
            throw "deployment-config.yaml must include Settings -> WorkSpace-Resource-Group and Workspace-Name"
          }

          # Locate and import the YamlToArm module from mdr_ruleconverter
          $modulePath = Join-Path $workspaceRoot 'mdr_ruleconverter/Modules/YamlToArm.psm1'
          if (-not (Test-Path $modulePath)) { throw "YamlToArm module not found at $modulePath" }
          Import-Module -Name $modulePath -Force -ErrorAction Stop

          # Resolve paths helper
          function Resolve-RulePath {
            param([string]$relativePath)
            $custPath = Join-Path "$workspaceRoot/mdr_cust" $relativePath
            $rootPath = Join-Path "$workspaceRoot/mdr_root" $relativePath
            if (Test-Path $custPath) { return $custPath }
            if (Test-Path $rootPath) { return $rootPath }
            return $null
          }

          # Prepare output location for the combined ARM template
          $outDir = Join-Path $env:RUNNER_TEMP 'mdr_ruleconverter_output'
          $null = New-Item -ItemType Directory -Path $outDir -Force
          $outFile = Join-Path $outDir 'armTemplate.json'
          if (Test-Path $outFile) { Remove-Item -LiteralPath $outFile -Force }

          # Determine workspace location (fallback to westeurope)
          $workspaceLocation = ''
          try { $workspaceLocation = (az monitor log-analytics workspace show --resource-group $resourceGroup --workspace-name $workspaceName --query location -o tsv 2>$null).Trim() } catch {}
          if (-not $workspaceLocation) { $workspaceLocation = 'westeurope' }

          Write-Host "Building ARM template with mdr_ruleconverter from filtered CSV"

          # Iterate CSV and merge each file into a single template
          $lines = Get-Content -Path $csvPath | Select-Object -Skip 1
          $processed = 0
          foreach ($line in $lines) {
            if (-not ($line -match '^(.*?),(.*)$')) { continue }
            $relativePath = $matches[1]

            $fullPath = Resolve-RulePath -relativePath $relativePath
            if (-not $fullPath) { Write-Warning "File not found for relative path: $relativePath. Skipping."; continue }

            try {
              Merge-ContentTemplate -InputFile $fullPath -OutputFile $outFile -Workspace $workspaceName -Location $workspaceLocation
              $processed++
            } catch {
              Write-Warning ("Failed to merge file: " + $relativePath + ". Error: " + $_.Exception.Message)
            }
          }

          if ($processed -eq 0) { Write-Host 'No files to convert. Skipping.'; exit 0 }
          if (-not (Test-Path $outFile)) { throw "ARM template was not created at $outFile" }

          # Deploy the generated ARM template
          Write-Host ("Deploying combined ARM template: {0}" -f $outFile)
          az deployment group create `
            --resource-group $resourceGroup `
            --mode Incremental `
            --name ("deploy-mdrrc-{0}" -f (Get-Date -Format 'yyyyMMddHHmmss')) `
            --template-file "$outFile" `
            --parameters workspace="$workspaceName" workspace-location="$workspaceLocation" `
            --only-show-errors 1>$null